### 一 打好基础
### 1.欢迎进入软件构建的世界
#### 1.1 什么是软件构建
1. 定义问题 problem definition
2. 需求分析 requirements development
3. 规划构建 construction planning
4. 软件架构 software architecture,或高层设计 high-level design
5. 详细设计 detailed design
6. 编码与调试 coding and debugging
7. 单元测试 unit testing
8. 集成测试 integration testing
9. 集成 integration
10. 系统测试 system testing
11. 保障维护 corrective maintenance

##### 具体任务 task
1. 验证有关的基础工作已经完成,因此构建活动可以顺利地进行下去.
2. 确定如何测试所写的代码.
3. 设计并编写类(class)和子程序(routine).
4. 创建并命名变量(variable)和具名常量(named constant).
5. 选择控制结构(control structure),组织语句块.
6. 对你的代码进行单元测试和集成测试,并排除其中的错误.
7. 评审开发团队其他成员的底层设计和代码,并让他们评审你的工作.
8. 润饰代码,仔细进行代码的格式化和注释.
9. 将单独开发的多个软件组建集成为一体.
10. 调整代码(tuning code),让它更快、更省资源.

#### 1.2 软件构建为何如此重要
1. 构建活动是软件开发的主要组成部分.
2. 构建活动室软件开发中的核心活动.
3. 把主要精力集中于构建活动,可以大大提高程序员的生产率.
4. 构建活动的产物--源代码--往往是对软件的唯一精确描述.
5. 构建活动是唯一一项确保会完成的工作.

#### 1.3 如何阅读本书
1. 软件构建是软件开发的核心活动,必不可少.
2. 软件构建的主要活动包括:详细设计、编码、调试、集成、开发者测试(单元测试和集成测试).
3. 构建通常被称作"编码"和"编程".
4. 构建活动的质量对软件的质量有着实质性的影响.
5. 最后,你对"如何进行构建"的理解程度,决定你这名程序员的优秀程度.

### 2. 用隐喻来更充分地理解软件开发
#### 2.1 隐喻的重要性
隐喻:又称之为建模.模型的威力在于其生动性,让你能够把握整个概念.它能隐隐地暗示各种属性(properties)、关系(relationships),以及需
要补充查证的部分.<br/>
你对隐喻有多理解,也就决定了你对软件开发有多理解.
#### 2.2 如何使用软件隐喻
隐喻的作用更像启示(heuristic,启发、试探法),而不是算法(algorithm).
#### 2.3 常见的软件隐喻
##### 软件中的书法: 写作代码
##### 软件的耕作法: 培植系统
##### 软件的牡蛎养殖观点: 系统生长
##### 软件构建: 建造软件
##### 应用软件技术: 智慧工具箱
##### 组合各个隐喻
##### 要点
1. 隐喻是启示而不是算法.因此它们往往有一点随意 sloopy.
2. 隐喻把软件开发过程与其他你熟悉的活动联系在一起,帮助你更好地理解.
3. 有些隐喻比其他一些隐喻更贴切.
4. 通过把软件的构建过程比作是房屋的建筑过程,我们可以发现,仔细的准备是必要的,而大型项目和小型项目之间也是有差异的.
5. 通过把软件开发中的实践比作是智慧工具箱的工具,我们又发现,每位程序员都有许多工具,但并不存在任何一个能适用于所有工作的工具,因地
制宜地选择正确工具是成为能有效编程的程序员的关键.
6. 不同的隐喻彼此并不排斥,应当使用对你最有益处的某种隐喻组合.

### 3. 三思而后行: 前期准备
#### 3.1 前期准备的重要性
使用高质量的实践方法是创造高质量软件的程序员的共性.<br/>
末期强调质量,强调系统测试.<br/>
中期强调质量,强调构建系统.<br/>
前期强调质量,强调计划,要求并设计高品质的产品.
##### 前期准备适用于现代软件项目吗?
##### 准备不周全的诱因
1. 实现做好计划能够避免很多压力.
2. 如何拒绝马上开始写代码<br/>
2.1. 糟糕的方法:直接拒绝.<br/>
2.2. 不太靠得住的方法:假装在写代码.<br/>
2.3. 教育你的老板,告诉他技术项目的微妙之处.
2.4. 找另一份工作.
##### 关于开始构建之前要做前期准备的绝对有力且简明的论据
实现一个系统之前,需要理解"这个系统应该做什么",以及"它该如何做到这些".
###### 诉诸逻辑
进行有效编程的要领之一是:准备工作很重要.
###### 诉诸类比
程序员是食物链的最后一环,如果食物链底层需求被污染,影响了架构,架构又污染构建.会导致程序员脾气暴躁、营养失调,开发出的软件周身都是
缺陷.
###### 诉诸数据
缺陷在软件食物链呆的时间越长,对于食物链的后级损害越严重.
###### 老板就绪
自我实现的预言
1. 最好立刻开始编码,因为会有很多调试工作需要做.
2. 没有为测试安排太多的时间,因为不会发现多少bug.
3. 已经非常详细地研究了需求和设计,想不出编码和调试期间会遇到什么大问题.

#### 3.2 辨明你所从事的软件类型
##### 迭代开发法对前期准备的影响
迭代开发法能减少"前期准备不足"造成的负面影响,但是不能完全消除影响.随着项目进行过程中一点点地吸收消化返工,使得总体成本较低.<br/>
一条很有用的经验规则是,计划好预先对大约80%的需求做出详细说明,并给"稍后再进行详细说明的额外需求"分配一定的时间.然后再项目进行过
程中,实施系统化的变更控制措施--只接受那些最有价值的新需求.另一种方案是,预先只对最重要的20%的需求做出详细说明,并且计划以小幅增量
开发软件的剩余部分.
##### 在序列式开发法和迭代开发法之间做出选择
更加序列化的原因
1. 需求相当稳定
2. 设计直截了当,并且理解透彻
3. 开发团队对于这一应用领域非常熟悉
4. 项目的风险很小
5. "长期可预测性"很重要
6. 后期改变需求、设计和编码的代价很可能较昂贵.

更加迭代的原因
1. 需求并没有被理解透彻,或者出于其他理由你认为它是不稳定的.
2. 设计很复杂,或者有挑战性,或者两者兼具
3. 开发团队对于这一应用领域不熟悉
4. 项目包含许多风险
5. "长期可预测性"不重要
6. 后期改变需求、设计和编码的代价很可能较低

#### 3.3. 问题定义的先决条件
开始构建之前,首先要满足的先决条件是,对系统要解决的问题做出清楚的陈述.又被称为"产品设想"、"任务陈述"或者"产品定义".<br/>
"问题定义"只定义了"问题是什么",而不涉及任何可能的解决方案.<br/>
"未能定义问题"的处罚是双重的,既没有解决正确的问题,又花费了大量时间去解决错误的问题.
#### 3.4. 需求的先决条件
"需求"详细描述软件系统应该做什么,这是达成解决方案的

